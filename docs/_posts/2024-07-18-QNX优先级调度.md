## 实时性

首先需要明确的是，实时性并不等同于执行效率。也就是说，实时性不保证任务处理得很快，而是确保任务将会在需要的时候迅速开始处理。换句话说，实时性更像是“我马上去办！”，而不是“我很快就办完！”。



### 优先级调度

为了实现实时性，QNX Neutrino RTOS提供了一种**优先级驱动**的**抢占**式体系结构。

**优先级驱动**意味着每个线程都可以被赋予优先级，并能够根据该优先级访问CPU。如果低优先级线程和高优先级线程都想运行，那么高优先级线程将是要运行的线程。

**抢占式**意味着，如果低优先级线程当前正在运行，然后高优先级线程突然想要运行，那么高优先级线程将接管CPU并运行，从而抢占低优先级线程。



#### 优先级和状态

在QNX中，线程可以具有范围从1到255（最高优先级）的调度优先级，数值越大优先级越高；非特权线程或者说普通线程的优先级可以在1到63之间，如果有需要对线程进行更高优先级的配置需要配合一些系统调用或者使用procnto工具（procnto -P）进行设置；线程的优先级存在继承关系，在默认情况下，线程继承其父线程的优先级，这里的继承是一种静态继承，是指新创建的线程（子线程）从创建它的线程（父线程）继承某些属性，包括优先级。这是一个静态的、一次性的过程，发生在子线程创建时。

事实上，线程不单单只有一种优先级，而是同时具有**实际优先级**和**有效优先级**，并根据其有效优先级进行调度，线程本身可以同时更改其实际优先级和有效优先级，但有效优先级可能会因为优先级继承或调度策略而更改。通常情况下，有效优先级与实际优先级相同。

除了线程的优先级以外，线程的状态也是调度器进行调度的一个必不可少的信息，在线程的动态创建和销毁的生命周期中，可能存在多个状态的转化，例如一个运行中（RUNNING）的线程可能在访问互斥锁的时候被其他线程阻止而变为阻塞状态（STATE_MUTEX），也可能正在等待来自另一个线程的消息而阻塞（STATE_RECEIVE），或者线程主动休眠（STATE_NANOSLEEP）。

![img](https://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.sys_arch/images/thread_states.png)

除了这里显示的转换之外，线程还可以从任何状态（DEAD除外）变为READY。

调度器通过查看处于READY状态（即能够使用CPU）的每个线程的优先级来选择下一个要运行的线程。为此内核维护了一个就绪队列，下图为内核中就绪队列数据结构的简化版本（在单核心系统上）：

![img](https://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.prog/images/readyq.png)

各个优先级共同构成一个优先级队列（长度256），每个优先级又包含一个就绪（READY）线程队列。任何未就绪的线程都不在任何队列中，处于优先级队列头的优先级最高的线程将被选择运行。

在上图中，线程A之前处于优先级10的队列的头，经过调度器的调度线程A现在变到RUNNING状态（享有CPU资源的使用），线程B–F已就绪，所有其他线程（G–Z）都被阻塞。

当一个正在运行的线程必须等待某个事件发生（对IPC请求的响应、对互斥体的等待等）时，它就会阻塞。假设RUNNING状态的线程A因为某种原因被阻塞，A随即将从正在运行的数组中删除，然后调度器运行优先级最高的就绪线程。当被阻塞的线程A随后被解除阻塞时，它通常被放置在该优先级的就绪队列的末尾：

![img](https://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.sys_arch/images/ablocks.png)

当然，也有一些情况下阻塞的线程被解除阻塞状态后不是重新排在队列的末尾：

- 一个非**FIFO**调度策略的服务器线程从RECEIVE阻塞状态中出来，并带有一条由其他客户端线程使用“nc”（non-cancellation point）版本的MsgSend*()发送的消息，该线程被插入到该优先级的队列的开头——也就是说，顺序是LIFO，而不是FIFO。
- 如果一个客户端线程使用“nc”（non-cancellation point）版本的MsgSend*()发送消息，那么当服务器回复时，该客户端线程将被放置在就绪队列的前面，而不是最后。如果调度策略**Round-robin（轮转）**的，则线程的时间片不会得到补充；例如，如果线程在发送之前已经使用了一半的时间片，那么在有资格进行抢占之前，它仍然只剩下一半的时间段。

对上述两个情况进行进一步说明之前，需要先对线程采取的调度策略有所了解。



#### 调度策略

调度策略并不是“宏观”的，换言之它不是应用于操作系统层面的，也不是应用于调度器层面的，而是线程层面的策略，即每个线程有自己的策略偏好。

为了满足不同的需求，QNX提供了三种调度策略：

- FIFO scheduling —— SECHED_FIFO

- Round-robin scheduling —— SECHED_RR

- Sporadic scheduling —— SCHED_SPORADIC

##### FIFO

FIFO是一种“先到先服务”的调度策略，也就是说FIFO一旦线程开始运行，它就会一直运行到完成，这意味着，如果该线程正在进行很长的数学计算，并且没有其他优先级更高的线程准备好，那么该线程可能会永远运行，除非：

1. 自愿放弃占用资源（blocked）
2. 被更高优先级的线程抢占资源

![img](https://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.prog/images/fifo.png)

> “自愿放弃”其实有两种方式。如果线程进入睡眠状态，或者阻塞信号量等，那么此时可以运行优先级较低的线程。但也有一个“特殊”调用，sched_yield()（基于内核调用SchedYield()），它只将CPU分配给具有相同优先级的另一个线程——如果有更高优先级的线程可以运行，那么低优先级的线程将永远不会有机会运行。如果一个线程实际上调用了sched_yield()，并且没有其他具有相同优先级的线程准备好运行，那么原始线程将继续运行。实际上，sched_yield()用于在CPU上给具有相同优先级的另一个线程一个使用机会。

##### Round-robin

Round-robin是一种“轮流服务”的调度策略，停止运行的条件是：

1. 自愿放弃占用资源（blocked）
2. 被更高优先级的线程抢占资源
3. 时间片耗尽

> 时间片是指分配给每个线程的时间单位。一旦它消耗了它的时间片，一个线程就被放在就绪队列中其队列的末尾，并且具有相同优先级的下一个READY线程被赋予控制权。
>
> 1时间片 = 4 * ticksize
>
> 如果处理器速度大于40 MHz，则ticksize默认为1毫秒；否则，它默认为10毫秒。因此，默认时间间隔是4毫秒（大多数CPU的默认时间间隔）或40毫秒（较慢硬件的默认时间段）。

可以看到Round-robin和FIFO的差别只在前者多了时间片的耗尽的情况。

![img](https://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.prog/images/robin.png)



##### Sporadic

Sporadic是一种为了处理偶发或者间歇性任务而设计的调度策略。这种策略是基于实时系统的需求，尤其是对于那些不可预测但又需要快速响应的任务。

###### **优先级管理**：

- Sporadic任务在其首次到达时被赋予一个高优先级，以确保它们能够立即获得处理。
- 之后，这些任务的优先级会被调整，以控制它们的执行频率，防止它们过度使用系统资源。

###### **执行频率控制**：

- Sporadic调度策略会限制Sporadic任务的执行频率，确保系统有足够的时间处理其他常规任务。
- 这可以通过设定一个最小间隔时间（Minimum Interarrival Time, MIT）来实现，即两次Sporadic任务之间的最小间隔时间。

相比于FIFO（First-In-First-Out）和Round-robin，Sporadic的主要区别在于它的调度决策不仅仅基于任务的到达顺序或者固定的时间片，而是需要考虑任务的实际需求和系统的当前状态。这使得Sporadic能够更好地处理实时性要求高的偶发或间歇性任务。



对于上述的调度策略，只有当共享相同优先级的两个或多个线程为READY（即，线程之间直接竞争）时才适用。如果一个优先级较高的线程变为READY，它会立即抢占所有优先级较低的线程。



#### 调度器

那么调度器是怎么知道什么时候该执行调度操作？又是谁来控制调度器的？

实际上，调度器是操作系统内核的一个关键组成部分，负责管理和分配系统的CPU资源，它并不是一个实际的进程，而是内核的一部分，其执行不依赖于用户空间的进程，而是由操作系统内核直接管理和调度。调度器的运行通常在特权模式（如内核模式）下进行，能直接访问硬件资源和内核数据结构。

上面提到调度器通过查看线程的状态来进行调度决策，然而它并不是一直“监控”各个线程的状态（而且本质上决定了它不具备轮询线程状态的能力——仅作为内核代码的一个执行片段），而是在特定的事件触发时被唤醒：

1. **线程阻塞**：当一个线程等待某些资源（如I/O操作，锁等）时，它会自己将自身状态设置为阻塞，并通知调度器。这通常是通过系统调用来完成的，例如读取文件、等待互斥锁等操作。

2. **线程完成**：当一个线程完成了其任务并退出时，它会通过一个系统调用（如exit()）通知操作系统，然后操作系统会通知调度器，调度器会挑选另一个线程来运行。

3. **时间片用完**：这通常是由硬件定时器产生的中断来实现的。当定时器到期时，它会产生一个中断，处理器会停止当前任务并跳转到中断处理程序。中断处理程序会通知调度器，然后调度器会选择新的线程来运行。

4. **优先级改变**：这通常是由线程自身或者操作系统来通知的。例如，线程可以通过系统调用来改变自己的优先级，或者当线程的状态改变（如从阻塞状态变为就绪状态）时，操作系统会重新评估其优先级。

所以，这些通知的消息是由线程自身、操作系统或硬件通过系统调用或中断来发出的。调度器会在接收到这些消息后进行相应的调度操作。

> 系统调用是一种使得用户态的程序能够请求并运行内核态代码的机制，以下是一些可能引发操作系统调度器进行调度的系统调用：
>
> 1. **fork() / clone()**：这两个系统调用用来创建新的进程（fork）或线程（clone）。新的进程或线程初始状态为就绪（READY），并可能由调度器立即选中执行。
> 2. **exit()**：这个系统调用用于结束当前进程的执行。调度器需要选择一个新的进程来使用CPU。
> 3. **wait() / waitpid()**：这些系统调用使得一个进程进入阻塞状态，等待其子进程结束。进程在阻塞状态中不会使用CPU，因此调度器需要选择一个新的进程来执行。
> 4. **sleep()**：这个系统调用使得一个进程暂时进入睡眠状态，不使用CPU一段时间。在这段时间内，调度器需要选择其他进程来使用CPU。
> 5. **sched_yield()**：这个系统调用使当前进程/线程主动放弃CPU，调度器会立即开始调度，选择一个新的进程或线程执行。
> 6. **pthread_setschedparam() / pthread_setschedprio()**：这些系统调用用于设置线程的调度参数，包括调度策略和优先级。这可能会影响调度器的决策。
>
> 这些都是可能触发操作系统调度的系统调用，但具体的行为可能会因操作系统的不同而有所差异。



我们按重要性顺序总结一下调度规则（针对单个CPU）

- 一次只能运行一个线程。

- 最高优先级就绪线程将运行。

- 线程将一直运行，直到它阻塞或退出。

- RR线程将在其时间片内运行，然后内核将重新调度它（如果需要）。

以下流程图显示了内核做出的决定：

![img](https://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.getting_started/images/dpt1.png)

对于多CPU系统，规则是相同的，除了多个CPU可以同时运行多个线程。线程运行的顺序（即哪些线程在CPU上运行）的确定方式与单个CPU完全相同：最高优先级的READY线程将在CPU上执行。





